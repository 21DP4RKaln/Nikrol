generator client {
  provider   = "prisma-client-js"
  engineType = "binary"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                  String               @id @default(uuid())
  email               String               @unique
  password            String
  firstName           String
  lastName            String
  role                Role                 @default(USER)
  isBlocked           Boolean              @default(false)
  blockReason         String?              @db.Text
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  profileImageUrl     String?
  accounts            Account[]
  auditLogs           AuditLog[]
  passwordResetTokens PasswordResetToken[]
  sessions            Session[]
  movies              Movie[]
  friendships         Friendship[]         @relation("UserFriendships")
  friendRequests      Friendship[]         @relation("FriendRequests")
  userMediaEntries    UserMediaEntry[]     // Новая связь

  @@map("user")
}

model AuditLog {
  id         String   @id @default(uuid())
  userId     String
  action     String
  entityType String
  entityId   String   @default("")
  details    String   @db.Text
  ipAddress  String?  @default("")
  userAgent  String?  @db.Text
  createdAt  DateTime @default(now())
  user       User     @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([action])
  @@index([entityType])
  @@index([createdAt])
  @@map("audit_log")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade, map: "account_user_fk")

  @@unique([provider, providerAccountId])
  @@index([userId], map: "accounts_userId_idx")
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade, map: "session_user_fk")

  @@index([userId], map: "sessions_userId_idx")
  @@map("sessions")
}

model PasswordResetToken {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  code      String
  type      String
  contact   String
  expiresAt DateTime
  used      Boolean  @default(false)
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade, map: "password_reset_token_user_fk")

  @@index([userId], map: "password_reset_tokens_userId_idx")
  @@map("password_reset_tokens")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verificationtokens")
}

// Глобальные фильмы/сериалы из IMDb
model GlobalMedia {
  id            String     @id @default(uuid())
  imdbId        String     @unique // ID из IMDb (например, tt0111161)
  title         String
  originalTitle String?
  description   String?    @db.Text
  releaseYear   Int?
  genres        String?    // JSON массив жанров
  director      String?
  cast          String?    @db.Text // JSON массив актеров
  posterUrl     String?
  backdropUrl   String?
  type          MediaType  @default(MOVIE)
  imdbRating    Float?
  duration      Int?       // в минутах
  countries     String?    // JSON массив стран
  languages     String?    // JSON массив языков
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt
  
  // Связи с пользовательскими списками
  userMediaEntries UserMediaEntry[]

  @@index([imdbId])
  @@index([type])
  @@index([title])
  @@index([releaseYear])
  @@map("global_media")
}

// Пользовательские записи о фильмах/сериалах
model UserMediaEntry {
  id            String          @id @default(uuid())
  userId        String
  globalMediaId String
  status        WatchStatus     @default(WANT_TO_WATCH)
  userRating    Float?          // личная оценка пользователя (1-10)
  personalNotes String?         @db.Text
  watchedAt     DateTime?       // дата просмотра
  startedAt     DateTime?       // дата начала просмотра
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  
  // Связи
  user          User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  globalMedia   GlobalMedia     @relation(fields: [globalMediaId], references: [id], onDelete: Cascade)
  
  // Для сериалов - отслеживание эпизодов
  episodeProgress EpisodeProgress[]
  @@unique([userId, globalMediaId])
  @@index([userId])
  @@index([globalMediaId])
  @@map("user_media_entries")
}

// Прогресс просмотра эпизодов (для сериалов)
model EpisodeProgress {
  id              String         @id @default(uuid())
  userMediaEntryId String
  season          Int
  episode         Int
  watched         Boolean        @default(false)
  watchedAt       DateTime?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  
  userMediaEntry  UserMediaEntry @relation(fields: [userMediaEntryId], references: [id], onDelete: Cascade)

  @@unique([userMediaEntryId, season, episode])
  @@index([userMediaEntryId])
  @@map("episode_progress")
}

// Старая модель Movie (для совместимости, можно будет удалить позже)
model Movie {
  id            String     @id @default(uuid())
  title         String
  description   String?    @db.Text
  releaseYear   Int?
  genre         String?
  director      String?
  posterUrl     String?
  type          MediaType  @default(MOVIE)
  rating        Float?
  duration      Int?       // в минутах
  userId        String
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt
  user          User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([type])
  @@index([genre])
  @@map("movies")
}

model Friendship {
  id          String           @id @default(uuid())
  userId      String
  friendId    String
  status      FriendshipStatus @default(PENDING)
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  user        User             @relation("UserFriendships", fields: [userId], references: [id], onDelete: Cascade)
  friend      User             @relation("FriendRequests", fields: [friendId], references: [id], onDelete: Cascade)

  @@unique([userId, friendId])
  @@index([userId])
  @@index([friendId])
  @@map("friendships")
}

enum MediaType {
  MOVIE
  TV_SERIES
}

enum FriendshipStatus {
  PENDING
  ACCEPTED
  DECLINED
  BLOCKED
}

enum WatchStatus {
  WANT_TO_WATCH    // Хочу посмотреть
  WATCHING         // Смотрю сейчас
  WATCHED          // Просмотрено
  ON_HOLD          // Приостановлено
  DROPPED          // Брошено
  REWATCHING       // Пересматриваю
}

enum Role {
  USER
  ADMIN
}
